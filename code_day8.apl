⍝   ==  Day 8  ==

⍝ Today, we stop cheating with the inputs and actually start
⍝ reading the data from an external file.

split ← {⍺(≠⊆⊢)⍵}

⍝ Function 3-train, which is equivalent to:
⍝   (⍺≠⍵) ⊆ (⍺⊢⍵)
⍝   (⍺≠⍵)         -> create a bitmask for every caracter that isn't the separator
⍝           (⍺⊢⍵) -> equivalent to ⍵
⍝         ⊆       -> use the bitmask to create a partition of the input⌈


onefourseveneight ← {↑+/{(⍴⍵)∊2 3 4 7}¨(' ' split (↑('|' split (↑⍵))[2]))}

⍝                                                  ↑('|' split (↑⍵))[2]       -> split on '|' and keep the second part
⍝                                       ' ' split  (                    )     -> split on ' ', and keep 
⍝                       {(⍴⍵)∊2 3 4 7}¨(                                 )    -> find all "digits" with 2, 3, 4 or 7 segments on
⍝                    ↑+/                                                      -> count them all, return a scalar

data ← ⎕NGET 'day8_1' 1
lines ← data[1]
+/onefourseveneight¨lines

⍝ data ← ⎕NGET 'day8_1' 1   -> read the file 'day8_1' and split lines⌈



⍝     === Part 2 ===

⍝ We are going to deduce the segments by adding and
⍝ substracting the sets of segments that belong to the
⍝ identifiable digits (1, 4, 7 and 8).
⍝ Here is the reasoning:
⍝   the only segment that appears 4 times => bottom left (e)
⍝   the only segment that appears 6 times => top left (b)
⍝   the only segment that appears 9 times => bottom right (f)
⍝   1 - f -> c
⍝   8 - 4 - 7 - 1 - e -> g
⍝   4 - b - c - f -> d
⍝   7 - c - f -> a

s ← 'abcdefg' 
bl←{l←⍵ ⋄ (({+/(l=⍵)}¨s)=4)/s}

⍝   l←⍵                         -> assign input line to l
⍝                    ¨s         -> for each possible segment
⍝           {+/(l=⍵)}           -> count the number of occurences of it
⍝          (           )=4      -> find the one that appears 4 times
⍝         (               )/s   -> and apply it to s to find the segment

tl←{l←⍵ ⋄ (({+/(l=⍵)}¨s)=6)/s}
br←{l←⍵ ⋄ (({+/(l=⍵)}¨s)=9)/s}

⍝ Same, but with 6 and 9 occurences

sub ← {n ← ⍵ ⋄ ({1-⍵∊n}¨⍺)/⍺}

⍝      n ← ⍵ ⋄                  -> the value we substract is assigned to n
⍝               {1-⍵∊n}¨⍺       -> create a binary mask of every element in ⍺ not present in ⍵
⍝              (         )/⍺    -> and apply to ⍺

one ← {d ← ' ' split ⍵ ⋄ ,↑(,↑{(⍴⍵)=2}¨d)/d}
four ← {d ← ' ' split ⍵ ⋄ ,↑(,↑{(⍴⍵)=4}¨d)/d}
seven ← {d ← ' ' split ⍵ ⋄ ,↑(,↑{(⍴⍵)=3}¨d)/d}
eight ← {d ← ' ' split ⍵ ⋄ ,↑(,↑{(⍴⍵)=7}¨d)/d}

⍝        d ← ' ' split ⍵ ⋄                   -> split the line into digits
⍝                          (,↑{(⍴⍵)=7}¨d)/d  -> find the element of d that is of length 7
⍝
⍝ (there is are a bunch of format operators in this function, but you could 
⍝  probably make that a bit cleaner...)

tr ← {(one ⍵) sub (br ⍵)}
b ← {(eight ⍵) sub ((four ⍵) ∪ (seven ⍵) ∪ (one ⍵) ∪ (bl ⍵))}
m ← {(four ⍵) sub ((tl ⍵) ∪ (tr ⍵) ∪ (br ⍵))}
t ← {(seven ⍵) sub ((tr ⍵) ∪ (br ⍵))}⌈

decode ← {(t ⍵), (tl ⍵), (tr ⍵), (m ⍵), (bl ⍵), (br ⍵), (b ⍵)}


translate ← {i ← ,↑{((decode ⍺)=⍵)/(⍳7)}¨⍵ ⋄ i[⍋i]}

⍝                ,↑{((decode ⍺)=⍵)/(⍳7)}¨⍵            -> use the vector generated by decode to translate the scrambled segments into the real ones
⍝                    (decode ⍺)=⍵                     -> create a bitmask, decoding the line input on ⍺, of the translated segment
⍝                ,  (            )/(⍳7)               -> find the actual number of the segment using its index in the decode vector
⍝                ,↑{                   }¨⍵            -> apply to every segment of the digit, then fix shape of the output to be a vector of scalars
⍝                                          ⋄ i[⍋i]}   -> sort output⌈
⍝ 
⍝ This function will translate a scrambled digit into a sorted
⍝ vector of correct segments lit up for the digit.


⍝  --- unifinished! ---